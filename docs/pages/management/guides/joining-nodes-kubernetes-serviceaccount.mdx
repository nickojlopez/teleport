---
title: Joining Nodes via Kubernetes ServiceAccount token
description: Use Kubernetes ServiceAccount tokens to join Nodes running in the same Kubernetes cluster than the Auth Service.
---

This guide will explain how to use the **Kubernetes join method** to configure
Teleport instances to join your Teleport cluster without sharing any
secrets when they are running in the same Kubernetes cluster than the Auth
servers.

<ScopedBlock scope="cloud">

The Kubernetes join method is not available in Teleport Cloud as it requires the
joining node to run in the same Kubernetes cluster as the Auth nodes.

</ScopedBlock>

The Kubernetes join method is available in self-hosted versions of Teleport 12+.
It is available to any Teleport Node or Proxy running in the same Kubernetes
cluster than the Auth server.

The Kubernetes ClusterRole `system:auth-delegator` is required on the Auth
servers ServiceAccount. Clusters deployed with the [`teleport-cluster` Helm
chart](../../reference/helm-reference/teleport-cluster.mdx) version 12 or
higher have the correct roles by default.

## Prerequisites

- A running Teleport cluster in Kubernetes. For details on how to set this up,
  see [Guides for running Teleport using Helm](../../deploy-a-cluster/helm-deployments.mdx).

- Editor access to the Kubernetes cluster running the Teleport cluster.
  You must be able to create Namespaces and Deployments.

- A Teleport user with `access` role, or any other role allowing to connect to
  applications wearing the labels `app: demo-app`

- Either the Teleport `editor` role, or the ability to `kubectl exec` into the
  existing Teleport Auth Nodes.

## Step 1/5. Create the Kubernetes provision token

Configure your Teleport Auth service with a special dynamic token (provision
token) which will allow Nodes from the Kubernetes cluster to join your Teleport
cluster.

Under the hood, the Teleport instance will prove to the Auth Service that
it is running in the same Kubernetes cluster by sending a signed ServiceAccount
Token which matches an allow rule configured in your Kubernetes provision token.

Create the following `token.yaml` with an `allow` rule specifying the Kubernetes
namespace and Kubernetes ServiceAccount in which your Teleport instances.

```yaml
# token.yaml
kind: token
version: v2
metadata:
  # the token name is not a secret because instances must prove that they are
  # running in your AWS account to use this token
  name: kubernetes-token
  # set a long expiry time, the default for tokens is only 30 minutes
  expires: "3000-01-01T00:00:00Z"
spec:
  # use the minimal set of roles required
  roles: [App]

  # set the join method allowed for this token
  join_method: kubernetes

  kubernetes:
    allow:
      # Service account names follow the format "namespace:serviceaccountname"
      - service_account: "teleport-agent:teleport-app-node"
```

<Tabs>
<TabItem label="Using local `tctl` as your current user">
Make sure your local `tctl` is at least at version 12 with `tctl version`.

Run `tctl create token.yaml` to create the token.

Finally, validate the token was created:

```code
$ tctl get token/kubernetes-token

kind: token
metadata:
  expires: "3000-01-01T00:00:00Z"
  name: kubernetes-token
spec:
  join_method: kubernetes
  roles:
  - App
version: v2
```

</TabItem>
<TabItem label="Using remote `tctl` as admin">
Retrieve the name and namespace of the Auth Nodes deployment:

```code
$ kubectl get namespaces
NAME              STATUS   AGE
cert-manager      Active   40d
default           Active   40d
kube-system       Active   40d
teleport          Active   40d

# We look for deployments in the "teleport" namespace
$ kubectl get deployments -n teleport
NAME             READY   UP-TO-DATE   AVAILABLE   AGE
teleport-auth    2/2     2            2           6d20h
teleport-proxy   2/2     2            2           6d20h

# Here, the deployment name is "teleport-auth".
```

Then run the following command to execute the `tctl create` directly from inside
one of the auth pod:

```code
$ kubectl exec -i -n teleport deployment/teleport-auth -- tctl create < token.yaml
```

Finally, validate the token was successfully created:

```code
$ kubectl exec -i -n teleport deployment/teleport-auth tctl get token/kubernetes-token

kind: token
metadata:
  expires: "3000-01-01T00:00:00Z"
  name: kubernetes-token
spec:
  join_method: kubernetes
  roles:
  - App
version: v2
```

</TabItem>
</Tabs>

## Step 2/5. Deploy a demonstration HTTP app

In this step we deploy a demonstration HTTP application and don't expose it
publicly. This application will be used to validate the Teleport Application
Access Node works as expected.

```code
$ kubectl create namespace demo-app
namespace/demo-app created

$ kubectl create deployment --image=nginx --namespace demo-app --port=80 demo-app
deployment.apps/demo-app created

$ kubectl expose deployment demo-app -n demo-app --port=80 --target-port=80 --selector='app=demo-app'
service/demo-app exposed
```

Validate the application pods are running and ready with the following command:

```code
$ kubectl get pods -n demo-app
NAME                        READY   STATUS    RESTARTS   AGE
demo-app-7664d59cb8-bvbmz   1/1     Running   0          67s
```

## Step 3/5. Configure your Application Access Nodes

The Kubernetes join method can be used for Teleport services running SSH, Proxy,
Kubernetes, Application, Database, or Windows desktop roles. The service should
be run in the same Kubernetes cluster and have a Kubernetes ServiceAccount Token
mounted. [The `teleport-kube-agent`
chart](../../reference/helm-reference/teleport-kube-agent.mdx) takes care of
this by default.

Configure the `teleport-kube-agent` chart by creating a `values.yaml` file with
the following content:

```yaml
# values.yaml

# Public address of the Teleport cluster with port.
# You must replace the placeholder with your proxy address.
proxyAddr: "teleport.example.com:443"

# Comma-separated list of roles to enable (any of: kube,db,app)
# In this guide we only deploy app access.
# Adding more roles here also requires to add role to the provision token created in step 1.
roles: app

joinParams:
  method: "kubernetes"
  # this must match the provision token created in Step 1.
  tokenName: "kubernetes-token"
  
apps:
  - name: demo-app
    uri: "http://demo-app.demo-app.svc.cluster.local:80"
```

## Step 4/5. Deploy the Application Access Node

Start the Teleport Application Access Node by running the following command:

```code
$ helm install teleport-app-node teleport/teleport-kube-agent -n teleport-agent --create-namespace -f values.yaml
```

Then, validate the pod is running after a couple of seconds:

```code
$ kubectl get pods -n teleport-agent
NAME                  READY   STATUS    RESTARTS   AGE
teleport-app-node-0   1/1     Running   0          23s
```

Finally, validate you can see the application in the Teleport web UI, or using the command line:

```code
$ tsh apps ls
Application Description Type Public Address       Labels              
----------- ----------- ---- -------------------- ------------------- 
demo-app                HTTP teleport.example.com teleport.dev/origin 
```

## Step 5/5. Cleanup

Delete both `demo-app` and `teleport-agent` namespaces, all the resources will
be recursively cleaned-up.

```code
$ kubectl delete namespaces demo-app teleport-agent
namespace "demo-app" deleted
namespace "teleport-agent" deleted
```

## Going further

- The possible values for `teleport-kube-agent` chart are documented [in its reference](../../reference/helm-reference/teleport-kube-agent.mdx).
- See [Application Access Guides](../../application-access/guides.mdx)
- See [Database Access Guides](../../database-access/guides.mdx)
